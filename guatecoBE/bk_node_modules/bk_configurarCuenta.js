const session = require('express-session');
const express = require('express');
const operations = require('../operations');
const router = express.Router()
module.exports = router

router.post('/', async (req, res) => {
    op = req.body.op;
    user = req.session.user;
    const data_password = req.body.data;
    switch (parseInt(op)) {
        case 1: //OBTENERMOS LA INFORMACION DEL USUARIO PARA MANDARLO AL FRONT
            res.setHeader('Content-Type', 'application/json');
            sql = "SELECT idUser, nombre, apellido, correo, telefono, direccion, userName FROM Usuario WHERE `idUser` = ?;";
            values = [user.id];
            operations.executeQuery(sql, values, (result) =>{ 
                res.send(JSON.stringify(result));
            });
        break;
        case 2://RECIBIMOS LA INFORMACION DEL USUARIO PARA ACTUALIZA. 
            res.setHeader('Content-Type', 'application/json');
            let user_data = req.body.data;

            //VERIFICAMOS QUE EL NOMBRE DE USUARIO Y/O CORREO ELECTRONICO NO EXISTAN
            const check_data = await new Promise((resolve, reject) => {
                sql = "SELECT userName, correo FROM Usuario WHERE  (userName = ? OR correo = ?) AND `idUser` NOT IN (?);";
                values = [user_data.userName, user_data.email, user.id];
                operations.executeQuery(sql, values, (result) =>{ 
                    let uN = false;
                    let eM = false;
                     if (result.length > 0) {
                        if (result[0].userName == user_data.userName) {
                            uN = true;
                        }
                        if(result[0].correo == user_data.email){
                            eM = true;
                        }
                     }
                     resolve({userName: uN, email: eM});
                });
            });

            //SI LOS DATOS ESTAN DISPONIBLES SE ACTUALIZA LA INFORMACION.
            if (!check_data.userName && !check_data.email) {
                sql = "UPDATE Usuario SET nombre = ?, apellido = ?, correo = ?, telefono = ?, direccion = ?, userName = ? WHERE idUser = ?";
                values = [user_data.firstName, user_data.lastName, user_data.email, user_data.phone, user_data.address, user_data.userName, user.id];
                operations.executeQuery(sql, values, (result) =>{
                });

                //ACTUALIZAMOS EL NOMBRE DE USUARIO DE LA SESSION.
                user.usuario = user_data.userName;
            }
            //MANDAMOS LOS RESULTADOS DE LAS OPERACIONES
            res.send(check_data);
        break;
        case 3:
            res.setHeader('Content-Type', 'application/json');
            const check_password = await new Promise((resolve, reject) => {
                sql = "SELECT passwordHash FROM Usuario WHERE idUser = ?;";
                values = [user.id];
                operations.executeQuery(sql, values, (result) =>{ 
                    const passwordMatch = operations.bcrypt.compareSync(data_password.oldPassword, result[0].passwordHash);
                    resolve(passwordMatch);
                });
            });

            if (check_password) {
                const plaintextPassword = data_password.newPassword;
                // Generar un salt (un valor aleatorio)
                const passwordSalt = operations.bcrypt.genSaltSync(10);
                // Hash de la contraseÃ±a con el salt
                const passwordHash = operations.bcrypt.hashSync(plaintextPassword, passwordSalt);
                sql = "UPDATE Usuario SET passwordHash = ? WHERE idUser = ?;";
                values = [passwordHash, user.id];
                operations.executeQuery(sql, values, (result) =>{ 
                });
            }
            res.send(check_password);
        break; 
    }
});
